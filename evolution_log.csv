island_id,iteration_num,function,score
0,0,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction result = new PlayerAction();\n    \n    // Iterate through all units of the player\n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() != player) {\n            continue;\n        }\n        \n        // Check if unit is a worker and not already harvesting\n        if (!u.getType().isWorker() || \n            (currentPlayerAction != null && currentPlayerAction.getUnitAction(u) != null &&\n             currentPlayerAction.getUnitAction(u).getType() == UnitAction.TYPE_HARVEST)) {\n            continue;\n        }\n        \n        // Find nearest unharvested resource\n        Unit target = null;\n        double minDist = Double.MAX_VALUE;\n        for (Unit r : game.getUnits()) {\n            if (r.getType().isResource() && r.getResources() > 0) {\n                int dx = Math.abs(u.getX() - r.getX());\n                int dy = Math.abs(u.getY() - r.getY());\n                double dist = Math.sqrt(dx*dx + dy*dy);\n                if (dist < minDist) {\n                    minDist = dist;\n                    target = r;\n                }\n            }\n        }\n        \n        // If target resource found, create harvest action\n        if (target != null) {\n            Harvest harvestAction = new Harvest();\n            harvestAction.target = target;\n            harvestAction.base = u;\n            harvestAction.pf = pf;\n            \n            // Check if action is valid\n            if (u.canExecuteAction(harvestAction, game)) {\n                result.addUnitAction(u, harvestAction.execute(game, new ResourceUsage()));\n            }\n        }\n    }\n    \n    return result;\n}\n'",-1.0
3,1,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    \n    // Get all units for the current player\n    List<Unit> units = game.getUnits();\n    for (Unit u : units) {\n        if (u.getPlayer() == player) {\n            // Check if the unit is a harvester\n            if (a_utt.getUnitType(u.getType().getName()).isHarvester()) {\n                // Check if the unit is idle\n                UnitAction currentAction = game.getUnitAction(u);\n                if (currentAction.getType() == UnitAction.TYPE_NONE) {\n                    // Find a resource to harvest\n                    for (Unit resource : game.getUnits()) {\n                        if (resource.getType().isResource() && resource.getPlayer() == -1) {\n                            // Check if the resource is adjacent\n                            if (Math.abs(u.getX() - resource.getX()) <= 1 && Math.abs(u.getY() - resource.getY()) <= 1) {\n                                // Calculate direction\n                                int dx = resource.getX() - u.getX();\n                                int dy = resource.getY() - u.getY();\n                                int direction = getDirection(dx, dy);\n                                \n                                // Create harvest action\n                                UnitAction harvestAction = new UnitAction(UnitAction.TYPE_HARVEST, direction);\n                                pa.addUnitAction(u, harvestAction);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return pa;\n}\n\nprivate int getDirection(int dx, int dy) {\n    if (dx == -1 && dy == 0) return UnitAction.DIRECTION_RIGHT;\n    if (dx == 1 && dy == 0) return UnitAction.DIRECTION_LEFT;\n    if (dx == 0 && dy == -1) return UnitAction.DIRECTION_DOWN;\n    if (dx == 0 && dy == 1) return UnitAction.DIRECTION_UP;\n    return UnitAction.DIRECTION_NONE;\n}\n'",-1.0
2,2,"'\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\n\nimport java.util.HashMap;\n\npublic class HarvestResources {\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        PlayerAction result = new PlayerAction();\n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() == player && u.getType().getHarvestAmount() > 0) {\n                if (currentPlayerAction.getUnitAction(u) == null) {\n                    Harvest harvestAction = new Harvest();\n                    harvestAction.unit = u;\n                    UnitAction unitAction = harvestAction.execute(game, new ResourceUsage());\n                    if (unitAction != null) {\n                        result.addUnitAction(u, unitAction);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n'",-1.0
1,0,"'\nimport ai.abstraction.AbstractAction;\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Harvest_Resources {\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        PlayerAction pa = new PlayerAction();\n        HashSet<Long> usedResources = new HashSet<>();\n\n        // Iterate over all units of the current player\n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() != player) {\n                continue;\n            }\n\n            // Check if the unit is a harvester (e.g., worker unit)\n            if (!isHarvester(u.getType())) {\n                continue;\n            }\n\n            // Skip if the unit already has an action assigned\n            if (currentPlayerAction.getAction(u) != null) {\n                continue;\n            }\n\n            // Find the nearest resource\n            Unit nearestResource = findNearestResource(u, game, usedResources);\n\n            if (nearestResource != null) {\n                // Mark the resource as used\n                usedResources.add(nearestResource.getID());\n                // Assign the Harvest action\n                Harvest harvestAction = new Harvest();\n                harvestAction.target = nearestResource;\n                pa.addUnitAction(u, new UnitAction(UnitAction.TYPE_HARVEST));\n            }\n        }\n\n        return pa;\n    }\n\n    private boolean isHarvester(UnitType type) {\n        // Implement logic to check if the unit type is a harvester\n        return type.getName().equals(""worker""); // Example implementation\n    }\n\n    private Unit findNearestResource(Unit harvester, GameState game, HashSet<Long> usedResources) {\n        Unit nearest = null;\n        int minDistance = Integer.MAX_VALUE;\n\n        for (Unit u : game.getUnits()) {\n            if (u.getType().isResource()) {\n                if (usedResources.contains(u.getID())) {\n                    continue;\n                }\n\n                int distance = Math.abs(harvester.getX() - u.getX()) + Math.abs(harvester.getY() - u.getY());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nearest = u;\n                }\n            }\n        }\n\n        return nearest;\n    }\n}\n'",-1.0
3,1,"'\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n\n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() == player && u.getType().isWorker() && u.getResources() == 0) {\n            Unit nearestResource = findNearestResource(u, game);\n            if (nearestResource != null) {\n                Harvest harvest = new Harvest();\n                harvest.target = nearestResource;\n                harvest.base = u;\n                UnitAction ua = harvest.execute(game, new ResourceUsage());\n                pa.addUnitAction(u, ua);\n            }\n        }\n    }\n\n    return pa;\n}\n\nprivate Unit findNearestResource(Unit worker, GameState game) {\n    Unit nearest = null;\n    int minDistance = Integer.MAX_VALUE;\n\n    for (Unit u : game.getUnits()) {\n        if (u.getType().isResource()) {\n            int distance = Math.abs(u.x - worker.x) + Math.abs(u.y - worker.y);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearest = u;\n            }\n        }\n    }\n\n    return nearest;\n}\n'",-1.0
2,2,"""\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    // Create a new PlayerAction if it's null\n    if (currentPlayerAction == null) {\n        currentPlayerAction = new PlayerAction();\n    }\n    \n    // Iterate through all units in the game state\n    for (Unit u : game.getUnits()) {\n        // Check if the unit belongs to the current player\n        if (u.getPlayer() == player) {\n            // Check if the unit is a worker or harvester\n            if (u.getType().isHarvester()) {\n                // Find a target resource (e.g., minerals, gas)\n                Unit targetResource = findTargetResource(game, u);\n                if (targetResource != null) {\n                    // Find a base to return to\n                    Unit base = findBase(game, u);\n                    if (base != null) {\n                        // Create a new Harvest action\n                        Harvest harvestAction = new Harvest();\n                        harvestAction.target = targetResource;\n                        harvestAction.base = base;\n                        harvestAction.pf = pf;\n                        \n                        // Add the harvest action to the current player action\n                        currentPlayerAction.addUnitAction(u, harvestAction.execute(game));\n                    }\n                }\n            }\n        }\n    }\n    \n    return currentPlayerAction;\n}\n\n// Helper method to find a target resource\nprivate Unit findTargetResource(GameState game, Unit harvester) {\n    // Implement logic to find nearest resource to the harvester\n    // This is a simplified example\n    for (Unit u : game.getUnits()) {\n        if (u.getType().isResource()) {\n            return u;\n        }\n    }\n    return null;\n}\n\n// Helper method to find a base\nprivate Unit findBase(GameState game, Unit harvester) {\n    // Implement logic to find the nearest base to the harvester\n    // This is a simplified example\n    for (Unit u : game.getUnits()) {\n        if (u.getType().isBase()) {\n            return u;\n        }\n    }\n    return null;\n}\n""",-1.0
3,3,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = (currentPlayerAction == null) ? new PlayerAction() : currentPlayerAction.clone();\n    \n    List<Unit> units = game.getUnits();\n    for (Unit u : units) {\n        if (u.getPlayer() == player && u.getType().isWorker()) {\n            if (u.getResources() == 0 || (u.getAction() == null || u.getAction().getType() != UnitAction.TYPE_HARVEST)) {\n                // Find a nearby resource\n                int[] directions = {0, 1, 2, 3};\n                for (int dir : directions) {\n                    int dx = UnitAction.DIRECTION_OFFSET_X[dir];\n                    int dy = UnitAction.DIRECTION_OFFSET_Y[dir];\n                    int nx = u.getX() + dx;\n                    int ny = u.getY() + dy;\n                    if (game.getPhysicalGameState().isResource(nx, ny)) {\n                        Harvest harvestAction = new Harvest();\n                        harvestAction.base = u;\n                        harvestAction.target = game.getPhysicalGameState().getUnitAt(nx, ny);\n                        harvestAction.pf = pf;\n                        \n                        UnitAction ua = harvestAction.execute(game, new ResourceUsage());\n                        if (ua != null) {\n                            pa.addUnitAction(u, ua);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
0,4,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    \n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() == player) {\n            // Check if the unit is a worker (can harvest)\n            if (u.getType().canHarvest()) {\n                Harvest harvestAction = new Harvest();\n                harvestAction.setUnit(u);\n                pa.addUnitAction(u, harvestAction);\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
2,0,"'\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Harvest_Resources {\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        PlayerAction newAction = new PlayerAction();\n        List<Unit> playerUnits = game.getUnits().stream()\n                .filter(u -> u.getPlayer() == player)\n                .collect(Collectors.toList());\n\n        for (Unit unit : playerUnits) {\n            if (unit.getHarvestAmount() > 0) {\n                if (unit.getResources() > 0) {\n                    List<Unit> bases = game.getUnits().stream()\n                            .filter(u -> u.getPlayer() == player && u.getType().isBase())\n                            .collect(Collectors.toList());\n                    if (!bases.isEmpty()) {\n                        Unit targetBase = findNearest(unit, bases);\n                        if (targetBase != null) {\n                            int targetPos = targetBase.getPosition(game.getPhysicalGameState());\n                            if (pf.pathExists(unit, targetPos, game, null)) {\n                                UnitAction ua = pf.findPathToAdjacentPosition(unit, targetPos, game, null);\n                                if (ua.getType() != UnitAction.TYPE_NONE) {\n                                    ua.setType(UnitAction.TYPE_RETURN);\n                                    newAction.addUnitAction(unit, ua);\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    List<Unit> resources = game.getUnits().stream()\n                            .filter(u -> u.getType().getHarvestAmount() > 0 && u.getPlayer() == -1)\n                            .collect(Collectors.toList());\n                    if (!resources.isEmpty()) {\n                        Unit targetResource = findNearest(unit, resources);\n                        if (targetResource != null) {\n                            int targetPos = targetResource.getPosition(game.getPhysicalGameState());\n                            if (pf.pathExists(unit, targetPos, game, null)) {\n                                UnitAction ua = pf.findPathToAdjacentPosition(unit, targetPos, game, null);\n                                if (ua.getType() != UnitAction.TYPE_NONE) {\n                                    ua.setType(UnitAction.TYPE_HARVEST);\n                                    newAction.addUnitAction(unit, ua);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return newAction;\n    }\n\n    private Unit findNearest(Unit unit, List<Unit> targets) {\n        if (targets.isEmpty()) {\n            return null;\n        }\n        Unit nearest = targets.get(0);\n        int minDist = Integer.MAX_VALUE;\n        for (Unit target : targets) {\n            int dist = Math.abs(target.getX() - unit.getX()) + Math.abs(target.getY() - unit.getY());\n            if (dist < minDist) {\n                minDist = dist;\n                nearest = target;\n            }\n        }\n        return nearest;\n    }\n}\n'",-1.0
2,0,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    List<Unit> units = game.getUnits();\n    for (Unit u : units) {\n        if (u.getPlayer() != player) {\n            continue;\n        }\n        if (u.getType().canHarvest()) {\n            if (currentPlayerAction.getActions().stream().noneMatch(p -> p.getKey().getID() == u.getID())) {\n                Harvest harvestAction = new Harvest();\n                harvestAction.base = findBase(game, u, a_utt);\n                harvestAction.target = findResource(game, u, a_utt);\n                if (harvestAction.target != null && harvestAction.base != null) {\n                    UnitAction ua = pf.findPathToAdjacentPosition(u, harvestAction.target.getPosition(), game, new ResourceUsage());\n                    if (ua != null) {\n                        ua.setType(UnitAction.TYPE_HARVEST);\n                        ua.setDirection(calculateDirection(u, harvestAction.target));\n                        pa.addUnitAction(u, ua);\n                    }\n                }\n            }\n        }\n    }\n    return pa;\n}\n\nprivate Unit findBase(GameState game, Unit u, UnitTypeTable a_utt) {\n    // Implementation to find the base unit\n}\n\nprivate Unit findResource(GameState game, Unit u, UnitTypeTable a_utt) {\n    // Implementation to find the nearest resource\n}\n\nprivate int calculateDirection(Unit u, Unit target) {\n    int dx = target.getX() - u.getX();\n    int dy = target.getY() - u.getY();\n    if (Math.abs(dx) > Math.abs(dy)) {\n        return dx > 0 ? UnitAction.DIRECTION_RIGHT : UnitAction.DIRECTION_LEFT;\n    } else {\n        return dy > 0 ? UnitAction.DIRECTION_DOWN : UnitAction.DIRECTION_UP;\n    }\n}\n'",-1.0
2,1,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = (currentPlayerAction != null) ? currentPlayerAction : new PlayerAction();\n    List<Unit> playerUnits = game.getUnits().stream()\n        .filter(u -> u.getPlayer() == player)\n        .toList();\n    \n    for (Unit u : playerUnits) {\n        UnitAction currentAction = game.getUnitAction(u);\n        if (currentAction != null && \n            (currentAction.getType() == UnitAction.TYPE_HARVEST || \n             currentAction.getType() == UnitAction.TYPE_RETURN)) {\n            continue;\n        }\n        \n        List<Unit> resources = game.getPhysicalGameState().getUnits().stream()\n            .filter(r -> r.getType().isResource())\n            .toList();\n        \n        if (!resources.isEmpty()) {\n            Unit targetResource = resources.stream()\n                .min(Comparator.comparingInt(r -> \n                    Math.abs(u.getX() - r.getX()) + Math.abs(u.getY() - r.getY())))\n                .orElse(null);\n            \n            if (targetResource != null) {\n                Harvest harvestAction = new Harvest();\n                harvestAction.base = u;\n                harvestAction.target = targetResource;\n                harvestAction.pf = pf;\n                \n                UnitAction action = harvestAction.execute(game, new ResourceUsage());\n                if (action != null && action.getType() == UnitAction.TYPE_HARVEST) {\n                    pa.addUnitAction(u, action);\n                }\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
1,2,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    HashSet<Unit> workers = new HashSet<>();\n    HashSet<Integer> harvestedResources = new HashSet<>();\n    \n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() == player && u.getType().name().equals(""Worker"")) {\n            workers.add(u);\n        }\n    }\n    \n    for (Unit u : workers) {\n        if (currentPlayerAction.getUnitAction(u) == null || currentPlayerAction.getUnitAction(u).getType() != UnitAction.TYPE_HARVEST) {\n            int[] resourcePositions = game.getPhysicalGameState().getResourcePositions();\n            for (int i = 0; i < resourcePositions.length; i += 2) {\n                int resX = resourcePositions[i];\n                int resY = resourcePositions[i + 1];\n                if (!harvestedResources.contains(i) && pf.pathToPositionInRangeExists(u, resX, resY, 2, game, new ResourceUsage())) {\n                    Harvest harvestAction = new Harvest();\n                    harvestAction.base = u;\n                    harvestAction.target = game.getUnitAt(resX, resY);\n                    harvestAction.pf = pf;\n                    if (harvestAction.target != null && !harvestedResources.contains(harvestAction.target.getID())) {\n                        pa.addUnitAction(u, harvestAction.execute(game, new ResourceUsage()));\n                        harvestedResources.add(harvestAction.target.getID());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return pa;\n}\n'",-1.0
1,3,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    List<Unit> allUnits = game.getUnits();\n    List<Unit> workers = new ArrayList<>();\n    List<Unit> resources = new ArrayList<>();\n    \n    // Separate workers and resources\n    for (Unit u : allUnits) {\n        if (u.getPlayer() == player) {\n            if (a_utt.getUnitType(u.getType().name).canHarvest) {\n                workers.add(u);\n            }\n        }\n        if (a_utt.getUnitType(u.getType().name).isResource) {\n            resources.add(u);\n        }\n    }\n    \n    // Track assigned resources\n    Set<Unit> assignedResources = new HashSet<>();\n    \n    for (Unit worker : workers) {\n        // Check if worker is idle and can harvest\n        if (worker.getResources() == 0 && worker.getUnitAction(game).getType() == UnitAction.TYPE_NONE) {\n            Unit nearestResource = null;\n            double minDistance = Double.MAX_VALUE;\n            \n            for (Unit res : resources) {\n                if (!assignedResources.contains(res)) {\n                    double distance = Math.sqrt(Math.pow(res.x - worker.x, 2) + Math.pow(res.y - worker.y, 2));\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        nearestResource = res;\n                    }\n                }\n            }\n            \n            if (nearestResource != null) {\n                // Check path to resource\n                if (pf.pathExists(worker, nearestResource.getPosition(), game, new ResourceUsage())) {\n                    Harvest harvestAction = new Harvest();\n                    harvestAction.target = nearestResource;\n                    harvestAction.base = worker;\n                    harvestAction.pf = pf;\n                    \n                    UnitAction ua = harvestAction.execute(game, new ResourceUsage());\n                    pa.addUnitAction(worker, ua);\n                    assignedResources.add(nearestResource);\n                }\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
0,0,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    List<Unit> units = game.getUnits();\n    \n    for (Unit u : units) {\n        if (u.getPlayer() != player) {\n            continue;\n        }\n        \n        if (u.isIdle(game)) {\n            List<UnitAction> possibleActions = u.getUnitActions(game);\n            for (UnitAction ua : possibleActions) {\n                if (ua.getType() == UnitAction.TYPE_HARVEST) {\n                    pa.addUnitAction(u, ua);\n                    break;\n                }\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
0,1,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction newActions = new PlayerAction();\n    List<Unit> playerUnits = game.getUnits().stream()\n        .filter(u -> u.getPlayer() == player)\n        .toList();\n\n    for (Unit unit : playerUnits) {\n        UnitType unitType = unit.getType();\n        if (!unitType.canHarvest()) continue;\n\n        UnitAction currentAction = game.getUnitAction(unit);\n        if (currentAction != null && currentAction.getType() == UnitAction.TYPE_HARVEST) continue;\n\n        int[][] directions = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n        for (int[] dir : directions) {\n            int targetX = unit.getX() + dir[0];\n            int targetY = unit.getY() + dir[1];\n            if (game.getPhysicalGameState().isInBounds(targetX, targetY)) {\n                Unit targetUnit = game.getUnitAt(targetX, targetY);\n                if (targetUnit != null && targetUnit.getType().isResource()) {\n                    UnitAction harvestAction = new UnitAction(UnitAction.TYPE_HARVEST, dir[0], dir[1]);\n                    if (game.isUnitActionAllowed(unit, harvestAction)) {\n                        newActions.addUnitAction(unit, harvestAction);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    currentPlayerAction.merge(newActions);\n    return currentPlayerAction;\n}\n'",-1.0
0,0,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction result = new PlayerAction();\n    List<Unit> playerUnits = game.getUnits().stream()\n        .filter(u -> u.getPlayer() == player)\n        .toList();\n\n    for (Unit unit : playerUnits) {\n        if (unit.getType().canHarvest() && !currentPlayerAction.getActions().containsKey(unit)) {\n            Unit targetResource = findNearestResource(game, unit, a_utt);\n            if (targetResource != null && pf.pathExists(unit, targetResource.getPosition(), game, new ResourceUsage())) {\n                Harvest harvestAction = new Harvest();\n                harvestAction.setUnit(unit);\n                harvestAction.setTarget(targetResource);\n                harvestAction.setBase(unit.getBase());\n                UnitAction action = harvestAction.execute(game, new ResourceUsage());\n                if (action != null && action.getType() == UnitAction.TYPE_HARVEST) {\n                    result.addUnitAction(unit, action);\n                }\n            }\n        }\n    }\n    return result;\n}\n\nprivate Unit findNearestResource(GameState game, Unit unit, UnitTypeTable utt) {\n    List<Unit> resources = game.getUnits().stream()\n        .filter(u -> u.getType().isResource())\n        .toList();\n\n    if (resources.isEmpty()) return null;\n\n    return resources.stream()\n        .min(Comparator.comparingInt(u -> (int) Math.hypot(u.getX() - unit.getX(), u.getY() - unit.getY())))\n        .orElse(null);\n}\n'",-1.0
1,1,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    List<Unit> units = game.getUnits();\n    for (Unit u : units) {\n        if (u.getPlayer() != player) continue;\n        if (!u.getType().canHarvest()) continue;\n        UnitAction currentAction = game.getUnitAction(u);\n        if (currentAction != null && currentAction.getType() == UnitAction.TYPE_HARVEST) continue;\n\n        Unit target = findResourceTarget(game, u, pf);\n        if (target == null) continue;\n\n        Harvest harvestAction = new Harvest();\n        harvestAction.unit = u;\n        harvestAction.target = target;\n        if (harvestAction.completed(game)) continue;\n\n        UnitAction ua = harvestAction.execute(game, new ResourceUsage());\n        if (ua != null) {\n            pa.addUnitAction(u, ua);\n        }\n    }\n    counterByFunction.put(1L, ""Harvest_Resources"");\n    return pa;\n}\n\nprivate Unit findResourceTarget(GameState game, Unit worker, PathFinding pf) {\n    for (int dx = -1; dx <= 1; dx++) {\n        for (int dy = -1; dy <= 1; dy++) {\n            int tx = worker.getX() + dx;\n            int ty = worker.getY() + dy;\n            if (game.free(tx, ty)) {\n                return new Unit(worker.getPlayer(), worker.getType(), tx, ty, 0);\n            }\n        }\n    }\n    return null;\n}\n'",-1.0
1,2,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    List<Unit> playerUnits = game.getUnits().stream()\n        .filter(u -> u.getPlayer() == player)\n        .toList();\n    \n    for (Unit u : playerUnits) {\n        if (a_utt.getUnitType(u.getType().name).canHarvest()) {\n            Unit target = findNearestResource(game, u, a_utt);\n            if (target != null) {\n                Harvest harvestAction = new Harvest();\n                harvestAction.target = target;\n                harvestAction.base = u;\n                pa.addUnitAction(u, harvestAction.execute(game));\n            }\n        }\n    }\n    \n    return pa;\n}\n\nprivate Unit findNearestResource(GameState game, Unit u, UnitTypeTable a_utt) {\n    int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n    for (int d=0; d<4; d++) {\n        int nx = u.getX() + dirs[d][0];\n        int ny = u.getY() + dirs[d][1];\n        Unit potentialTarget = game.getUnitAt(nx, ny);\n        if (potentialTarget != null && a_utt.getUnitType(potentialTarget.getType().name).isResource()) {\n            return potentialTarget;\n        }\n    }\n    return null;\n}\n'",-1.0
3,0,"'\nimport ai.abstraction.AbstractAction;\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\npublic class HarvestResources {\n\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        PlayerAction pa = (currentPlayerAction == null) ? new PlayerAction() : currentPlayerAction.clone();\n        HashSet<Unit> processedUnits = new HashSet<>();\n        \n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() != player) continue;\n            if (!u.getType().isWorker()) continue;\n            if (processedUnits.contains(u)) continue;\n            \n            Unit targetResource = findNearestResource(game, u);\n            if (targetResource == null) continue;\n            \n            Harvest harvestAction = new Harvest();\n            harvestAction.unit = u;\n            harvestAction.target = targetResource;\n            harvestAction.base = findBase(game, u, player);\n            harvestAction.pf = pf;\n            \n            ResourceUsage ru = currentPlayerAction != null ? currentPlayerAction.getResourceUsage() : new ResourceUsage();\n            UnitAction ua = harvestAction.execute(game, ru);\n            \n            if (ua != null) {\n                pa.addUnitAction(u, ua);\n                processedUnits.add(u);\n            }\n        }\n        \n        return pa;\n    }\n    \n    private Unit findNearestResource(GameState game, Unit u) {\n        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n        for (int[] dir : dirs) {\n            int nx = u.getX() + dir[0];\n            int ny = u.getY() + dir[1];\n            Unit resource = game.getUnitAtPosition(nx, ny);\n            if (resource != null && resource.getType().isResource()) {\n                return resource;\n            }\n        }\n        return null;\n    }\n    \n    private Unit findBase(GameState game, Unit u, int player) {\n        // Logic to find the nearest base for the worker\n        // Implementation details depend on game specifics\n        return null; // Replace with actual base finding logic\n    }\n}\n'",-1.0
1,1,"""\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\nimport java.util.*;\n\npublic class HarvestResourcesFunction {\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        PlayerAction newPA = new PlayerAction();\n        Set<Long> assignedResources = new HashSet<>();\n\n        // Find all workers of the player\n        List<Unit> workers = new ArrayList<>();\n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() == player && u.getType().isWorker()) {\n                workers.add(u);\n            }\n        }\n\n        // Find all resource units\n        List<Unit> resources = new ArrayList<>();\n        for (Unit u : game.getUnits()) {\n            if (u.getType().isResource()) {\n                resources.add(u);\n            }\n        }\n\n        // Find the base (home base) of the player\n        Unit base = null;\n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() == player && u.getType().isBase()) {\n                base = u;\n                break;\n            }\n        }\n        if (base == null) {\n            return newPA; // No base, can't harvest\n        }\n\n        // Assign each worker to the nearest resource\n        for (Unit worker : workers) {\n            Unit target = null;\n            double minDistance = Double.MAX_VALUE;\n            for (Unit res : resources) {\n                if (!assignedResources.contains(res.getID())) {\n                    int dx = Math.abs(worker.getX() - res.getX());\n                    int dy = Math.abs(worker.getY() - res.getY());\n                    double distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        target = res;\n                    }\n                }\n            }\n            if (target != null) {\n                // Create Harvest action\n                Harvest harvestAction = new Harvest();\n                harvestAction.unit = worker;\n                harvestAction.target = target;\n                harvestAction.base = base;\n                harvestAction.pf = pf;\n\n                // Get ResourceUsage from current action or create new\n                ResourceUsage ru = (currentPlayerAction != null) ? currentPlayerAction.getResourceUsage() : new ResourceUsage();\n\n                // Execute the action to get the UnitAction\n                UnitAction ua = harvestAction.execute(game, ru);\n\n                // Add the action to the new PlayerAction\n                newPA.addUnitAction(worker, ua);\n                assignedResources.add(target.getID());\n            }\n        }\n\n        return newPA;\n    }\n}\n""",-1.0
0,2,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    PhysicalGameState pgs = game.getPhysicalGameState();\n    List<Unit> units = pgs.getUnits();\n    \n    for (Unit u : units) {\n        if (u.getPlayer() == player) {\n            UnitAction currentAction = game.getUnitAction(u);\n            if (currentAction == null || currentAction.getType() == UnitAction.TYPE_NONE) {\n                List<UnitAction> possibleActions = u.getUnitActions(game);\n                for (UnitAction ua : possibleActions) {\n                    if (ua.getType() == UnitAction.TYPE_HARVEST) {\n                        pa.addUnitAction(u, ua);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return pa;\n}\n'",0.0
1,3,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction result = new PlayerAction();\n    List<Unit> units = game.getUnits();\n    \n    for (Unit u : units) {\n        if (u.getPlayer() != player) continue;\n        if (game.getUnitAction(u) != null) continue;\n        if (!u.isIdle(game)) continue;\n        \n        Unit target = findNearestResource(game, u, a_utt);\n        Unit base = findNearestBase(game, u, a_utt);\n        \n        if (target != null && base != null) {\n            Harvest harvestAction = new Harvest();\n            harvestAction.target = target;\n            harvestAction.base = base;\n            harvestAction.pf = pf;\n            \n            UnitAction action = harvestAction.execute(game);\n            if (action != null && action.getType() == UnitAction.TYPE_HARVEST) {\n                result.addUnitAction(u, action);\n            }\n        }\n    }\n    \n    return result;\n}\n\nprivate Unit findNearestResource(GameState game, Unit u, UnitTypeTable utt) {\n    List<Unit> resources = game.getUnits().stream()\n        .filter(unit -> unit.getType().isResource())\n        .sorted((a, b) -> Integer.compare(getDistance(u, a), getDistance(u, b)))\n        .toList();\n    \n    return resources.isEmpty() ? null : resources.get(0);\n}\n\nprivate Unit findNearestBase(GameState game, Unit u, UnitTypeTable utt) {\n    List<Unit> bases = game.getUnits().stream()\n        .filter(unit -> unit.getType().isBase())\n        .sorted((a, b) -> Integer.compare(getDistance(u, a), getDistance(u, b)))\n        .toList();\n    \n    return bases.isEmpty() ? null : bases.get(0);\n}\n\nprivate int getDistance(Unit a, Unit b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n'",-1.0
1,0,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = (currentPlayerAction == null) ? new PlayerAction() : currentPlayerAction.clone();\n    \n    List<Unit> playerUnits = game.getUnits().stream()\n        .filter(u -> u.getPlayer() == player)\n        .toList();\n    \n    for (Unit u : playerUnits) {\n        if (u.isIdle(game)) {\n            Harvest harvestAction = new Harvest();\n            harvestAction.setUnit(u);\n            harvestAction.setTarget(u); // Set target unit\n            harvestAction.setBase(u); // Set base unit\n            \n            if (u.canExecuteAction(harvestAction, game)) {\n                pa.addUnitAction(u, harvestAction.execute(game, new ResourceUsage()));\n            }\n        }\n    }\n    \n    return pa;\n}\n'",-1.0
2,1,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction newActions = new PlayerAction();\n    ResourceUsage ru = new ResourceUsage();\n\n    for (Unit unit : game.getUnits()) {\n        if (unit.getPlayer() == player && unit.getType().isWorker() && unit.getResources() == 0) {\n            // Find the nearest resource\n            Unit targetResource = null;\n            double minDist = Double.MAX_VALUE;\n            for (Unit potentialResource : game.getUnits()) {\n                if (potentialResource.getType().isResource()) {\n                    double dist = Math.hypot(unit.getX() - potentialResource.getX(), unit.getY() - potentialResource.getY());\n                    if (dist < minDist) {\n                        minDist = dist;\n                        targetResource = potentialResource;\n                    }\n                }\n            }\n            if (targetResource != null) {\n                // Find the nearest base\n                Unit base = null;\n                minDist = Double.MAX_VALUE;\n                for (Unit potentialBase : game.getUnits()) {\n                    if (potentialBase.getPlayer() == player && potentialBase.getType().isStructure()) {\n                        double dist = Math.hypot(unit.getX() - potentialBase.getX(), unit.getY() - potentialBase.getY());\n                        if (dist < minDist) {\n                            minDist = dist;\n                            base = potentialBase;\n                        }\n                    }\n                }\n                if (base != null) {\n                    // Check if path exists\n                    if (pf.pathExists(unit, targetResource.getPosition(), game, ru)) {\n                        Harvest harvest = new Harvest();\n                        harvest.target = targetResource;\n                        harvest.base = base;\n                        harvest.pf = pf;\n                        UnitAction action = harvest.execute(game, ru);\n                        newActions.addUnitAction(unit, action);\n                    }\n                }\n            }\n        }\n    }\n\n    return newActions;\n}\n'",-1.0
2,2,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    if (game == null || game.gameover()) return pa;\n    if (!game.canExecuteAnyAction(player)) return pa;\n\n    List<Unit> playerUnits = game.getUnits();\n    for (Unit u : playerUnits) {\n        if (u.getPlayer() != player) continue;\n        if (u.getType().getHarvestAmount() <= 0) continue;\n        if (currentPlayerAction.getUnitAction(u) != null) continue;\n\n        Unit target = findNearestResource(game, u);\n        if (target == null) continue;\n\n        if (!pf.pathExists(u, target.getX(), target.getY(), game, new ResourceUsage())) continue;\n\n        Harvest harvestAction = new Harvest();\n        harvestAction.setUnit(u);\n        harvestAction.setTarget(target);\n        harvestAction.setBase(u.getBase());\n        harvestAction.setPathfinding(pf);\n        UnitAction ua = harvestAction.execute(game, new ResourceUsage());\n        if (ua != null) {\n            pa.addUnitAction(u, ua);\n        }\n    }\n\n    return pa;\n}\n\nprivate Unit findNearestResource(GameState game, Unit u) {\n    List<Unit> resources = game.getUnits().stream()\n        .filter(unit -> unit.getType().isResource() && unit.getPlayer() == -1)\n        .toList();\n\n    if (resources.isEmpty()) return null;\n\n    return resources.stream()\n        .min((a, b) -> {\n            int distA = Math.abs(a.getX() - u.getX()) + Math.abs(a.getY() - u.getY());\n            int distB = Math.abs(b.getX() - u.getX()) + Math.abs(b.getY() - u.getY());\n            return Integer.compare(distA, distB);\n        })\n        .orElse(null);\n}\n'",-1.0
3,3,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    PlayerAction pa = new PlayerAction();\n    HashSet<Integer> usedPositions = new HashSet<>();\n\n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() == player && u.getType().canHarvest()) {\n            UnitAction currentAction = game.getUnitAction(u);\n            if (currentAction == null || currentAction.getType() == UnitAction.TYPE_NONE) {\n                int[][] directions = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n                for (int[] dir : directions) {\n                    int tx = u.getX() + dir[0];\n                    int ty = u.getY() + dir[1];\n                    if (tx >= 0 && tx < game.getPhysicalGameState().width && ty >= 0 && ty < game.getPhysicalGameState().height) {\n                        int pos = game.getPhysicalGameState().pos(tx, ty);\n                        if (game.getPhysicalGameState().getTile(pos) == PhysicalGameState.RESOURCE_TILE && !usedPositions.contains(pos)) {\n                            if (pf.pathExists(u, pos, game, new ResourceUsage())) {\n                                Harvest harvestAction = new Harvest();\n                                harvestAction.setTargetPosition(tx, ty);\n                                pa.addUnitAction(u, harvestAction);\n                                usedPositions.add(pos);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return pa;\n}\n'",-1.0
3,4,"'\nimport ai.abstraction.AbstractAction;\nimport ai.abstraction.Harvest;\nimport ai.abstraction.pathfinding.PathFinding;\nimport rts.GameState;\nimport rts.PlayerAction;\nimport rts.ResourceUsage;\nimport rts.units.Unit;\nimport rts.units.UnitTypeTable;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\npublic class Harvest_Resources {\n    public PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n        if (currentPlayerAction == null) {\n            currentPlayerAction = new PlayerAction();\n        }\n\n        HashSet<Unit> processedUnits = new HashSet<>();\n        for (Unit u : game.getUnits()) {\n            if (u.getPlayer() == player && !processedUnits.contains(u)) {\n                if (u.isIdle(game) && u.getType().canHarvest()) {\n                    Unit target = findNearestResource(game, u);\n                    if (target != null) {\n                        if (pf.pathExists(u, target.getPosition(), game, new ResourceUsage())) {\n                            Harvest harvestAction = new Harvest();\n                            harvestAction.setUnit(u);\n                            harvestAction.target = target;\n                            UnitAction action = harvestAction.execute(game, new ResourceUsage());\n                            if (action.getType() == UnitAction.TYPE_HARVEST) {\n                                currentPlayerAction.addUnitAction(u, action);\n                                processedUnits.add(u);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return currentPlayerAction;\n    }\n\n    private Unit findNearestResource(GameState game, Unit unit) {\n        int minDistance = Integer.MAX_VALUE;\n        Unit nearestResource = null;\n        for (Unit u : game.getUnits()) {\n            if (u.getType().isResource() && !u.isDead()) {\n                int distance = Math.abs(u.getX() - unit.getX()) + Math.abs(u.getY() - unit.getY());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nearestResource = u;\n                }\n            }\n        }\n        return nearestResource;\n    }\n}\n'",-1.0
2,5,"'\npublic PlayerAction Harvest_Resources(GameState game, int player, PlayerAction currentPlayerAction, PathFinding pf, UnitTypeTable a_utt, HashMap<Long, String> counterByFunction) {\n    if (currentPlayerAction == null) {\n        currentPlayerAction = new PlayerAction();\n    }\n    for (Unit u : game.getUnits()) {\n        if (u.getPlayer() == player) {\n            List<UnitAction> possibleActions = u.getUnitActions(game);\n            for (UnitAction ua : possibleActions) {\n                if (ua.getType() == UnitAction.TYPE_HARVEST) {\n                    currentPlayerAction.addUnitAction(u, new UnitAction(UnitAction.TYPE_HARVEST));\n                    break;\n                }\n            }\n        }\n    }\n    return currentPlayerAction;\n}\n'",0.0
